<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet/less" type="text/css" href="https://xmenfolk.github.io/theme/stylesheet/style.less">
    <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js" type="text/javascript"></script>

  <link rel="stylesheet" type="text/css" href="https://xmenfolk.github.io/theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="https://xmenfolk.github.io/theme/stylesheet/font-awesome.min.css">


    <link href="https://xmenfolk.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Angie's Blog Atom">


    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

<meta name="author" content="Angie" />
<meta name="description" content="kafka背景 Kafka最初是由LinkedIn开发，并于2011年成为Apache的一个开源项目，随后在2012变为Apache的一个顶级项目。kafka是由Scala和Java语言编写的的。Kafka是一个基于发布-订阅，具有容错的消息系统。具有高性能，可扩展，分布式等特性。 kafka介绍 在大数据领域中，我们会使用了大量的数据。 关于大数据，我们有两个主要挑战。第一个挑战是如何收集大量的数据，第二个挑战是分析收集到的数据。为了克服这些挑战，你需要一个消息系统。Kafka的设计目标就是称为一个分布式，高吞吐量的消息系统。Kafka也可以作为一个传统的消息中间件的替代品。 与其他消息系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。 什么是消息系统？ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循pub-sub。 点对点消息系统 在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。 下图描述了结构。 发布-订阅消息系统 在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 一个现实生活的例子是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并在这些订阅的频道可用时获得它们。 kafka是什么？ Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。 优点 以下是Kafka的几个优点： 可靠性 - Kafka 是一个分布式，消息分区的，拥有消息复制和容错的系统。 扩展性 - Kafka消息系统可以实现在线扩展 可用性 - Kafka 使用 “分布式的commit log”，这也意味着消息会尽可能快的持久化到磁盘。 高性能 - Kafka 针对消息发送和消费都有很高的吞吐量。 即使保存了TB级别的数据性能也不会下降。 Kafka 非常快并保证零宕机和零消息丢失。 用例 kafka通常用于下面的使用场景： 监控 Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。 日志聚合方案 kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。 流式处理 流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行处理，然后将处理的结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。 need for Kafka Kafka是一个统一的平台，用于处理所有实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供对容错的保证。它具有处理大量不同消费者的能力。 Kafka非常快，执行2百万w/s。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统（RAM）的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。 Kafka基础概念 在深入了解Kafka之前，你应该先了解一些基本的术语。像topics,brokers,producers,consumers。下图说明了主要的术语并且表格对这些术语进行了详细的解释。 在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0, 1, 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。 假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上 …" />
<meta name="keywords" content="[TechnologyArchitecture]">
<meta property="og:site_name" content="Angie's Blog"/>
<meta property="og:title" content="KafKa入门"/>
<meta property="og:description" content="kafka背景 Kafka最初是由LinkedIn开发，并于2011年成为Apache的一个开源项目，随后在2012变为Apache的一个顶级项目。kafka是由Scala和Java语言编写的的。Kafka是一个基于发布-订阅，具有容错的消息系统。具有高性能，可扩展，分布式等特性。 kafka介绍 在大数据领域中，我们会使用了大量的数据。 关于大数据，我们有两个主要挑战。第一个挑战是如何收集大量的数据，第二个挑战是分析收集到的数据。为了克服这些挑战，你需要一个消息系统。Kafka的设计目标就是称为一个分布式，高吞吐量的消息系统。Kafka也可以作为一个传统的消息中间件的替代品。 与其他消息系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。 什么是消息系统？ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循pub-sub。 点对点消息系统 在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。 下图描述了结构。 发布-订阅消息系统 在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 一个现实生活的例子是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并在这些订阅的频道可用时获得它们。 kafka是什么？ Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。 优点 以下是Kafka的几个优点： 可靠性 - Kafka 是一个分布式，消息分区的，拥有消息复制和容错的系统。 扩展性 - Kafka消息系统可以实现在线扩展 可用性 - Kafka 使用 “分布式的commit log”，这也意味着消息会尽可能快的持久化到磁盘。 高性能 - Kafka 针对消息发送和消费都有很高的吞吐量。 即使保存了TB级别的数据性能也不会下降。 Kafka 非常快并保证零宕机和零消息丢失。 用例 kafka通常用于下面的使用场景： 监控 Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。 日志聚合方案 kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。 流式处理 流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行处理，然后将处理的结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。 need for Kafka Kafka是一个统一的平台，用于处理所有实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供对容错的保证。它具有处理大量不同消费者的能力。 Kafka非常快，执行2百万w/s。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统（RAM）的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。 Kafka基础概念 在深入了解Kafka之前，你应该先了解一些基本的术语。像topics,brokers,producers,consumers。下图说明了主要的术语并且表格对这些术语进行了详细的解释。 在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0, 1, 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。 假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上 …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://xmenfolk.github.io/posts/kafkaIntroduction/"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-04-19 00:00:00-03:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://xmenfolk.github.io/author/angie.html">
<meta property="article:section" content="[技术架构]"/>
<meta property="article:tag" content="[TechnologyArchitecture]"/>
<meta property="og:image" content="/images/profile.jpg">
  <title>Angie's Blog &ndash; KafKa入门</title>
</head>
<body>
  <aside>
    <div>
      <a href="https://xmenfolk.github.io">
        <img src="/images/profile.jpg" alt="Angie" title="Angie">
      </a>
      <h1><a href="https://xmenfolk.github.io">Angie</a></h1>
      <p>A programmer who love rock and roll</p>
      <nav>
        <ul class="list">
          <li><a href="/pages/about.html">关于自己</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-facebook" href="https://facebook.com" target="_blank"><i class="fa fa-facebook"></i></a></li>
        <li><a class="sc-github" href="https://github.com/XMenfolk" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-google" href="https://google.com.hk" target="_blank"><i class="fa fa-google"></i></a></li>
      </ul>
    </div>

    <!--form class="navbar-search pull-right" action="/search.html">
      <input type="text" class="search-query" placeholder="Search" name="q" id="s">
   </form>-->

  </aside>
  <main>
    <nav>
      <a href="https://xmenfolk.github.io">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="https://xmenfolk.github.io/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h1 id="kafkaIntroduction">KafKa入门</h1>
    <p>Posted on 周三 19 四月 2017 in <a href="https://xmenfolk.github.io/category/ji-zhu-jia-gou.html">[技术架构]</a></p>
  </header>
  <div>
    <h3>kafka背景</h3>
<p>Kafka最初是由LinkedIn开发，并于2011年成为Apache的一个开源项目，随后在2012变为Apache的一个顶级项目。kafka是由Scala和Java语言编写的的。Kafka是一个基于发布-订阅，具有容错的消息系统。具有高性能，可扩展，分布式等特性。</p>
<h3>kafka介绍</h3>
<p>在大数据领域中，我们会使用了大量的数据。 关于大数据，我们有两个主要挑战。第一个挑战是如何收集大量的数据，第二个挑战是分析收集到的数据。为了克服这些挑战，你需要一个消息系统。Kafka的设计目标就是称为一个分布式，高吞吐量的消息系统。Kafka也可以作为一个传统的消息中间件的替代品。 与其他消息系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。</p>
<h4>什么是消息系统？</h4>
<p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循pub-sub。</p>
<h4>点对点消息系统</h4>
<p>在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。 下图描述了结构。  </p>
<p><img alt="01" src="/postsimage/kafkaIntroduction/point-to-point-model.jpeg">  </p>
<h4>发布-订阅消息系统</h4>
<p>在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 一个现实生活的例子是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并在这些订阅的频道可用时获得它们。<br>
<img alt="02" src="/postsimage/kafkaIntroduction/pub-sub-model.jpeg">  </p>
<h4>kafka是什么？</h4>
<p>Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。</p>
<h4>优点</h4>
<p>以下是Kafka的几个优点：</p>
<p>可靠性 - Kafka 是一个分布式，消息分区的，拥有消息复制和容错的系统。
扩展性 - Kafka消息系统可以实现在线扩展
可用性 - Kafka 使用 “分布式的commit log”，这也意味着消息会尽可能快的持久化到磁盘。
高性能 - Kafka 针对消息发送和消费都有很高的吞吐量。 即使保存了TB级别的数据性能也不会下降。</p>
<p>Kafka 非常快并保证零宕机和零消息丢失。</p>
<h4>用例</h4>
<p>kafka通常用于下面的使用场景：</p>
<ul>
<li>监控
Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。</li>
<li>日志聚合方案
kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。</li>
<li>流式处理
流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行处理，然后将处理的结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。</li>
</ul>
<h4>need for Kafka</h4>
<p>Kafka是一个统一的平台，用于处理所有实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供对容错的保证。它具有处理大量不同消费者的能力。 Kafka非常快，执行2百万w/s。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统（RAM）的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。  </p>
<h3>Kafka基础概念</h3>
<p>在深入了解Kafka之前，你应该先了解一些基本的术语。像topics,brokers,producers,consumers。下图说明了主要的术语并且表格对这些术语进行了详细的解释。
<img alt="03" src="/postsimage/kafkaIntroduction/kafka-foundamental.jpeg"><br>
在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0, 1, 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。</p>
<p>假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上。为了在集群的节点间进行负载，每一个broker都会保存一个或多个这样的分区。多个producer和consumer可以同时发布或获取消息。  </p>
<table>
<thead>
<tr>
<th align="left">Components</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">topics</td>
<td align="left">隶属于特定分类的消息流称为topic。数据保存在topic中</td>
</tr>
<tr>
<td align="left">partitions</td>
<td align="left">topics会被切分为分区。针对每一个主题，kafka最少保持一个分区。每一个这样的分区以顺序不可变的方式保存消息。一个分区有一个或多个大小相同的segment文件组成。Topics拥有多个分区，因此可以保存大量的数据</td>
</tr>
<tr>
<td align="left">Partition offset</td>
<td align="left">每个分区中的消息拥有一个唯一的序列id,被称为offset</td>
</tr>
<tr>
<td align="left">Replicas of partition</td>
<td align="left">分区副本仅仅是分区的备份，不会对副本分区进行读写操作，只是用来防止数据丢失。</td>
</tr>
<tr>
<td align="left">Brokers</td>
<td align="left">1. Brokers 是维护发布消息的系统。每个broker针对每个topic可能包含0个或多个该topic的分区。假设，一个topic拥有N个分区，并且集群拥有N个broker,则每个broker会负责一个分区。2. 假设，一个topic拥有N个分区，并且集群拥有N+M个broker,则前N个broker每个处理一个分区，剩余的M个broker则不会处理任何分区 3.假设，一个topic拥有N个分区，并且集群拥有M个broker（M &lt; N），则这些分区会在所有的broker中进行均匀分配。每个broker可能会处理一个或多个分区。这种场景不推荐使用，因为会导致热点问题和负载不均衡问题。</td>
</tr>
<tr>
<td align="left">Kafka Cluster</td>
<td align="left">由多个broker组成的kafka被称为kafka集群。一个kafaka集群在不停机扩展。集群负载所有消息的持久化和副本处理。</td>
</tr>
<tr>
<td align="left">Producers</td>
<td align="left">Producers 是向一个或多个Kafka中topic发布消息的发布者。Producers 将消息发送到 Kafka 的</td>
</tr>
<tr>
<td align="left">Consumers</td>
<td align="left">Consumers 从broker读取数据。Consumers 订阅一个或多个 topic，并通过pull方式从broker拉取订阅的数据。</td>
</tr>
<tr>
<td align="left">Leader</td>
<td align="left">Leader是负责某个分区数据读写操作的节点。每个分区都有一个leader</td>
</tr>
<tr>
<td align="left">Follower</td>
<td align="left">跟随leader操作的节点被称为follower。如果leader节点不可用，则会从所有的fellower中挑选一个作为新的leader节点。一个follower节点作为leader节点一个普通的消费者，拉取leader数据并更新自己的数据存储。</td>
</tr>
</tbody>
</table>
<h3>Kafka集群架构</h3>
<p>看看下面的插图。 它显示了Kafka的集群工作原理。  </p>
<p><img alt="04" src="/postsimage/kafkaIntroduction/kafka-cluster.jpeg"> <br>
下面的表格描述了在上图中提到的每个组件的详细信息。  </p>
<table>
<thead>
<tr>
<th align="left">Components</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Broker</td>
<td align="left">Kafka集群通常使用多个Broker来实现集群的负载均衡。 Kafka brokers 是无状态的，因为它们使用</td>
</tr>
<tr>
<td align="left">ZooKeeper</td>
<td align="left">ZooKeeper是用来管理和协调Kafka broker 的。ZooKeeper 服务主要用来通知 producer 和 consumer 关于任何新加入Kafka集群或某个Kafka Broker宕机退出集群的消息。 根据收到Zookeeper的关于Broker的存在或失败的消息通知，然后生产者和消费者采取决定，并开始与其它Broker协调它们的任务。</td>
</tr>
<tr>
<td align="left">Producers</td>
<td align="left">producer将数据推送给Broker。 当新Broker启动时，所有生产者搜索它并自动发送消息到该新Broker。 Kafka Producer不等待来自Broker的确认，并以Broker可以处理的速度发送消息。</td>
</tr>
<tr>
<td align="left">Consumers</td>
<td align="left">由于 Kafka brokers 是无状态的， 因此需要Consumer来维护根据partition offset已经消费的消息数量信息。 如果 consumer 确认了一个指定消息的offset，那也就意味着 consumer 已经消费了该offset之前的所有消息。Consumer可以向Broker异步发起一个拉取消息的请求来缓存待消费的消息。consumers 也可以通过提供一个指定的offset值来回溯或跳过Partition中的消息。Consumer 消费消息的offset值是保存在ZooKeeper中的。</td>
</tr>
</tbody>
</table>
<h3>Kafka工作流程</h3>
<p>到目前为止，我们讨论了Kafka的核心该概念。现在让我们将目光转向Kafka的工作流程上。Kafka是由分裂为一个或多个partition的topic的集合。 Kafka中的partition可以认为是消息的线性排序序列，其中每个消息由它们的索引（称为offset）来标识。 Kafka集群中的所有数据是每个partition数据分区的并集。 新写入的消息写在分区的末尾，消息由消费者顺序读取。通过将消息复制到不同的Broker来提供持久性。Kafka以快速，可靠，持久，容错和零停机的方式提供基于pub-sub和队列模型的消息系统。 在这两种情况下，生产者只需将消息发送到topic，消费者可以根据自己的需要选择任何一种类型的消息传递系统。 让我们按照下一节中的步骤来了解消费者如何选择他们选择的消息系统。</p>
<h4>Pub-Sub 消息模型工作流程</h4>
<p>下面是 Pub-Sub 消息模型的工作流程</p>
<ul>
<li>生产者定期向topic发送消息。</li>
<li>Kafka broker 根据配置将topic的消息存储到指定的partition上。Kafka确保所有的消息均匀分布在topic的所有partition上。如果producer发送了两条消息，并且该topic有两个partition，则每个partition会有一条消息。</li>
<li>Consumer 订阅指定的topic。</li>
<li>一旦消费者订阅了topic，Kafka将向消费者提供topic的当前offset，并且还将offset保存在Zookeeper中。</li>
<li>消费者将定期请求Kafka（如100 Ms）新消息。</li>
<li>一旦Kafka从生产者接收到消息，它将这些消息转发给消费者。</li>
<li>消费者将收到消息并进行处理。</li>
<li>一旦消息被处理，消费者将向Kafka broker发送确认。</li>
<li>一旦Kafka收到确认，它将offset更改为新值，并在Zookeeper中更新它。 由于offset在Zookeeper中被维护，消费者可以正确地读取下一条消息，即使服务器宕机后重启。</li>
<li>以上流程将重复，直到消费者停止请求。</li>
<li>消费者可以随时回退/跳转到某个topic的期望offset处，并读取所有后续消息。</li>
</ul>
<h4>队列消息模型工作流程 &amp; Consumer Group</h4>
<p>在基于队列的消息系统中，取代单个消费者的是订阅了相同topic的一群拥有相同Group ID的消费者集群。简单来说，订阅具有相同“组ID”的主题的消费者被认为是单个组，并且消息在它们之间共享。 让我们检查这个系统的实际工作流程。</p>
<p>生产者定期向topic发送消息。
Kafka broker 根据配置将topic的消息存储到指定的partition上。
单个consumer以名为Group-1的Group ID 订阅名为Topic-01的topic。
Kafka 会以和Pub-Sub消息模型相同的方式和consumer进行交互知道新的消费者以同样的Group ID加入到消费者分组中。
一旦新的消费者加入后，Kafka将操作切换到共享模式，将所有topic的消息在两个消费者间进行均衡消费。这种共享行为直到加入的消费者结点数目达到该topic的分区数。
一旦消费者的数目大于topic的分区数，则新的消费者不会收到任何消息直到已经存在的消费者取消订阅。出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。
该功能被称为 “Consumer Group”。以同样的方式，Kafka将以非常简单和高效的方式提供这两种系统功能。</p>
<h4>ZooKeeper的角色</h4>
<p>Apache Kafka的一个关键依赖是Apache Zookeeper，它是一个分布式配置和同步服务。 Zookeeper是Kafka代理和消费者之间的协调接口。 Kafka服务器通过Zookeeper集群共享信息。 Kafka在Zookeeper中存储基本元数据，例如关于主题，代理，消费者偏移（队列读取器）等的信息。由于所有关键信息存储在Zookeeper中，并且它通常在其整个集群上复制此数据，因此Zookeeper的故障不会影响Kafka集群的状态。一旦Zookeeper重新启动， Kafka将恢复状态。 这为Kafka带来了零停机时间。 Kafka代理之间的领导者选举也通过使用Zookeeper在领导失败的情况下完成。
要了解更多关于Zookeeper，请参考http://www.tutorialspoint.com/zookeeper/  </p>
<h3>Kafka安装步骤</h3>
<p>下面是在你机器上安装Java的步骤：</p>
<h4>步骤 1: 校验Java是否安装</h4>
<p>但愿你的机器上已经安装了Java环境，因此你可以通过下面的命令检查Java是否已经安装。</p>
<div class="highlight"><pre><span></span>$ java -version
</pre></div>


<p>如果你的机器上已经安装了Java，则你会看到Java的版本信息。</p>
<p>步骤 1.1: 下载 JDK
如果你还没有下载JDK，则可以通过下面的链接下载最新版本的JDK。http://www.oracle.com/technetwork/java/javase/downloads/index.html
目前最新的JDK版本是JDK 8u 60 文件名为： “jdk-8u60-linux-x64.tar.gz”。</p>
<p>步骤 1.2: 解压文件
通常，正在下载的文件存储在下载文件夹中，使用下面的命令进行文件校验和解压。</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> /go/to/download/path
$ tar -zxf jdk-8u60-linux-x64.gz
</pre></div>


<p>步骤 1.3: 进入Opt文件夹
为了让Java对所有人都是可用的，需要将解压后的内容移动到/usr/local/java文件夹下</p>
<div class="highlight"><pre><span></span>$ su
password: <span class="o">(</span><span class="nb">type</span> password of root user<span class="o">)</span> $ mkdir /opt/jdk
$ mv jdk-1.8.0_60 /opt/jdk/
</pre></div>


<p>步骤 1.4: 设置path环境变量
可以同步下面的命令设置path和JAVA_HOME环境变量</p>
<div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">JAVA_HOME</span> <span class="o">=</span>/usr/jdk/jdk-1.8.0_60
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$JAVA_HOME</span>/bin
</pre></div>


<p>是上面的配置生效：</p>
<div class="highlight"><pre><span></span>$ <span class="nb">source</span> ~/.bashr
</pre></div>


<p>Step 1.5: Java Alternatives
Use the following command to change Java Alternatives.</p>
<div class="highlight"><pre><span></span>update-alternatives --install /usr/bin/java java /opt/jdk/jdk1.8.0_60/bin/java <span class="m">100</span><span class="sb">`</span>
</pre></div>


<p>Step 1.6: Now verify java using verification command (java -version) explained in Step 1.</p>
<h4>步骤 2: ZooKeeper 框架安装</h4>
<p>步骤 2.1: 下载 ZooKeeper
通过下面的链接下载zookeeper并安装
http://zookeeper.apache.org/releases.html</p>
<p>到目前为止最新的 ZooKeeper 版本是 3.4.6 (ZooKeeper-3.4.6.tar.gz).</p>
<p>步骤 2.2: 解压 tar 文件
通过下面的命令解压文件：</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> opt/
$ tar  -zxf  zookeeper-3.4.6.tar.gz
$ <span class="nb">cd</span> zookeeper-3.4.6
$ mkdir data
</pre></div>


<p>步骤 2.3: 创建配置文件
用vi打开名为conf/zoo.cfg的配置文件并在配置文件中添加如下的内容：</p>
<div class="highlight"><pre><span></span>$ vi conf/zoo.cfg
<span class="nv">tickTime</span><span class="o">=</span><span class="m">2000</span>
<span class="nv">dataDir</span><span class="o">=</span>/path/to/zookeeper/data
<span class="nv">clientPort</span><span class="o">=</span><span class="m">2181</span>
<span class="nv">initLimit</span><span class="o">=</span><span class="m">5</span>
<span class="nv">syncLimit</span><span class="o">=</span><span class="m">2</span>
</pre></div>


<p>完成配置文件的创建后你就可以启动Zookeeper服务器了。</p>
<p>步骤 2.4: 启动 ZooKeeper Server</p>
<div class="highlight"><pre><span></span>$ bin/zkServer.sh start
</pre></div>


<p>在该命令执行后你可以看到下面的反馈信息：</p>
<div class="highlight"><pre><span></span>$ JMX enabled by default
$ Using config: /Users/../zookeeper-3.4.6/bin/../conf/zoo.cfg $ Starting zookeeper ... STARTED
</pre></div>


<p>步骤 2.5: 启动命令行工具</p>
<div class="highlight"><pre><span></span>$ bin/zkCli.sh
</pre></div>


<p>在输入上面的命令后，你会连接到Zookeeper服务器并得到下面的响应信息：</p>
<div class="highlight"><pre><span></span>Connecting to localhost:2181
................
................
................
Welcome to ZooKeeper!
................
................
WATCHER::
WatchedEvent state:SyncConnected type: None path:null <span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> <span class="m">0</span><span class="o">]</span>
</pre></div>


<p>步骤 2.6: 停止 Zookeeper Server
在连接到Zookeeper并执行了一些操作后你可以通过下面的命令来停止Zookeeper。</p>
<div class="highlight"><pre><span></span>$ bin/zkServer.sh stop
</pre></div>


<p>现在你已经在你的机器上成功安装了Java和Zookeeper，接下来我们将安装Kafka。</p>
<h4>步骤 3: 安装Apache Kafka</h4>
<p>步骤 3.1: 下载 Kafka
点击下面的链接来下载kafka:
https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz</p>
<p>步骤 3.2: 解压tar文件
使用下面的命令解压下载的文件：</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> opt/
$ tar  -zxf kafka_2.11.0.9.0.0 tar.gz
$ <span class="nb">cd</span> kafka_2.11.0.9.0.0
</pre></div>


<p>Step 3.3: 启动 Server
你可以通过下面的命令启动Server:</p>
<div class="highlight"><pre><span></span>$ bin/kaka-server-start.sh config/server.properties
</pre></div>


<p>在服务启动后，你回在屏幕上看到如下的信息：</p>
<div class="highlight"><pre><span></span>$ bin/kaka-server-start.sh config/server.properties
<span class="o">[</span><span class="m">2016</span>-01-02 <span class="m">15</span>:37:30,410<span class="o">]</span> INFO KafkaConfig values:
request.timeout.ms <span class="o">=</span> <span class="m">30000</span>
log.roll.hours <span class="o">=</span> <span class="m">168</span> inter.broker.protocol.version <span class="o">=</span> <span class="m">0</span>.9.0.X    log.preallocate <span class="o">=</span> <span class="nb">false</span> security.inter.broker.protocol <span class="o">=</span> PLAINTEXT
   ....................................................
   ....................................................
</pre></div>


<p>步骤 4: 停止 the Server
在执行完所有的操作后你可以通过下面的命令停止服务：</p>
<div class="highlight"><pre><span></span>$ bin/kaka-server-stop.sh config/server.properties
</pre></div>


<p>目前我们已经完成了Kafka的安装，接下来我们来看看kafka的基本操作。</p>
<h3>Kafka基本操作</h3>
<p>首先让我们实现单个结点的Broker，随后看看如何搭建多结点的Kafka集群。</p>
<p>希望你已经安装了Java，Zookeeper, Kafka。在搭建Kafka集群前你应该先启动ZooKeeper ，因为Kafka集群依赖ZooKeeper。</p>
<h4>Start ZooKeeper</h4>
<p>打开一个新的终端并输入下面的命令：</p>
<div class="highlight"><pre><span></span>bin/zookeeper-server-start.sh config/zookeeper.properties
</pre></div>


<p>输入下面的命令启动Kafka Server:</p>
<div class="highlight"><pre><span></span>bin/kafka-server-start.sh config/server.properties
</pre></div>


<p>在启动Kafka Broker后，在启动Zookeeper的终端窗口输入jps命令你会看到如下的输出：</p>
<div class="highlight"><pre><span></span><span class="m">821</span> QuorumPeerMain
<span class="m">928</span> Kafka
<span class="m">931</span> Jps    
</pre></div>


<p>现在你应该可以在终端看到两个守护进程，QuorumPeerMain 是 ZooKeeper 另一个是Kafka。</p>
<h4>单个Broker结点配置</h4>
<p>在这个配置中，你有一个ZooKeeper和一个Broker实例。 以下是配置步骤：
创建Kafka主题：Kafka提供了一个名为“kafka-topics.sh”的命令行实用程序来在服务器上创建主题。 打开新终端并键入以下示例。</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">1</span> -- partitions <span class="m">1</span> --topic topic-name
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">1</span> -- partitions <span class="m">1</span> --topic Hello-Kafka
</pre></div>


<p>我们刚才创建了一个名为Hello-Kafka,一个分区和一个副本的topic。上面命令的输出信息如下：</p>
<p>输出: Created topic “Hello-Kafka”</p>
<h4>List of Topics</h4>
<p>为了获取Kafka服务器上的topic列表，你可以使用下面的命令：</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">1</span> -- partitions <span class="m">1</span> --topic topic-name
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">1</span> -- partitions <span class="m">1</span> --topic Hello-Kafka
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>Hello-Kafka
</pre></div>


<p>由于我们只创建了一个名为Hello-Kafka的topic，则只会有上面的输出。如果你创建了很多topic则你回获取更过topic名称列表。</p>
<h4>启动Producer发送消息</h4>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name
</pre></div>


<p>从上面的语法我们可以看到有两个重要参数是必须的：Broker-list - 指定我们要发送消息到的Broker列表。在这个例子中我们只有一个Broker。配置文件 server.properties中指定了Broker的端口号，由于我们已经指定了Broker的端口号所以我们可以直接指定；
topic-name：我们发送消息所属的topic。</p>
<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka
</pre></div>


<p>生产者将等待来自标准输入的输入并发布到Kafka集群。 默认情况下，每个新行都作为一条新消息发布，生产者使用配置文件config/producer.properties中指定缺省属性。 现在你可以在终端中键入几行消息，如下所示。</p>
<p>输出</p>
<div class="highlight"><pre><span></span>$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka
<span class="o">[</span><span class="m">2016</span>-01-16 <span class="m">13</span>:50:45,931<span class="o">]</span> WARN property topic is not valid <span class="o">(</span>kafka.utils.Verifia- bleProperties<span class="o">)</span>
Hello
My first message
My second message
</pre></div>


<h4>启动消费者接收消息</h4>
<p>和生产者类似，消费者默认的属性配置在配置文件config/consumer.properties文件中。开发一个新的终端，输入如下的命令来消费消息：</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic topic-name --from- beginning
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Hello-Kafka --from- beginning    
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>Hello
My first message
My second message
</pre></div>


<p>最后，你可以从生产者的终端输入消息，并看到它们出现在消费者的终端。 到目前为止，你对具有单个broker的单节点群集有非常好的了解。 现在让我们继续讨论多个代理配置。</p>
<h4>多节点配置</h4>
<p>在搭建多结点Kafka节点集群时首先启动你的Zookeeper服务。</p>
<p>创建多节点Kafka Broker – 我们已经拥有了一个Kafka Broker实例，它使用的配置文件是config/server.properties中。 现在我们需要多个代理实例，因此将现有的server.proties文件复制到两个新的配置文件中，并将其重命名为server-one.properties和server-two.properties。 然后编辑这两个新文件并分配以下更改：</p>
<p>config/server-one.properties</p>
<div class="highlight"><pre><span></span><span class="c1"># The id of the broker. This must be set to a unique integer for    each broker. </span>
broker.id<span class="o">=</span><span class="m">1</span>
<span class="c1"># The port the socket server listens on</span>
<span class="nv">port</span><span class="o">=</span><span class="m">9093</span>
<span class="c1"># A comma seperated list of directories under which to store log files </span>
log.dirs<span class="o">=</span>/tmp/kafka-logs-1
</pre></div>


<p>config/server-two.properties</p>
<div class="highlight"><pre><span></span><span class="c1"># The id of the broker. This must be set to a unique integer for    each broker. </span>
broker.id<span class="o">=</span><span class="m">2</span>
<span class="c1"># The port the socket server listens on</span>
<span class="nv">port</span><span class="o">=</span><span class="m">9094</span>
<span class="c1"># A comma seperated list of directories under which to store log files </span>
log.dirs<span class="o">=</span>/tmp/kafka-logs-2
</pre></div>


<p>启动多个Broker – 在完成上面的修改后，打开三个终端来启动三个Broker节点。</p>
<div class="highlight"><pre><span></span>Broker1
bin/kafka-server-start.sh config/server.properties
Broker2
bin/kafka-server-start.sh config/server-one.properties
Broker3
bin/kafka-server-start.sh config/server-two.properties
</pre></div>


<p>现在我们用了三个不同Broker结点在同一个机器上，你可以通过jps命令来校验，你会看到对应的输出。</p>
<h4>创建topic</h4>
<p>让我们将副本因子设为3，因为我们拥有三个Broker实例，如果你拥有两个Broker则你设置为2。</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">3</span> -par- titions <span class="m">1</span> --topic topic-name
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor <span class="m">3</span> -partitions <span class="m">1</span> --topic Multibrokerapplication
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>created topic “Multibrokerapplication”
</pre></div>


<p>Describe 命令用来检查指定topic的详细信息，如下：</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic Multibrokerapplication
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic Multibrokerapplication

Topic:Multibrokerapplication PartitionCount:1 ReplicationFactor:3 Configs: Topic:Multibrokerapplication Partition:0 Leader:0 Replicas:0,2,1 Isr:0,2,1 
</pre></div>


<p>从上面的输出，我们可以得出结论，第一行给出所有分区的摘要，显示topic名称，分区数量和我们已经选择的复制因子。 在第二行中，每个节点将是分区的随机选择的领导者。
在我们的例子中，我们看到我们的第一个broker（with broker.id 0）是领导者。 然后Replicas：0,2,1意味着所有的Broker已经完成topic的复制。Isr是in-sync副本的集合。这是副本的子集，当前活着的并和leader保持同步的结点。</p>
<h4>启动生产者发送消息</h4>
<p>这个生产者和前面提到的单个Broder结点中的生产者是一样的。</p>
<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Multibrokerappli- cation    
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Multibrokerappli- cation
<span class="o">[</span><span class="m">2016</span>-01-20 <span class="m">19</span>:27:21,045<span class="o">]</span> WARN Property topic is not valid <span class="o">(</span>kafka.utils.Verifia-bleProperties<span class="o">)</span>
This is single node-multi broker demo
This is the second message
</pre></div>


<h4>启动消费者接收消息</h4>
<p>这个消费者和前面提到的单个Broder结点中的消费者是一样的。</p>
<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Multibrokerapplication --from-beginning
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Multibrokerapplication —from-beginning
This is single node-multi broker demo
This is the second message
</pre></div>


<h4>基本操作</h4>
<p>该本章节我们来讨论Kafka的各种基本操作。</p>
<h4>修改Topic</h4>
<p>由于你已经在Kafka集群创建了topic，现在让我们修改已经创建的topic的信息。</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic topic_name --partitions count
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>We have already created a topic “Hello-Kafka” with single partition count and one replica factor. Now using “alter” <span class="nb">command</span> we have changed the partition count.

bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic Hello-kafka --parti- tions <span class="m">2</span>
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>WARNING: If partitions are increased <span class="k">for</span> a topic that has a key, the partition logic or ordering of the messages will be affected
Adding partitions succeeded!
</pre></div>


<h4>删除topic</h4>
<p>可以通过下面的语法删除topic</p>
<p>语法</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic topic_name
</pre></div>


<p>例子</p>
<div class="highlight"><pre><span></span>bin/kafka-topics.sh –zookeeper localhost:2181 –delete –topic Hello-kafka
</pre></div>


<p>输出</p>
<div class="highlight"><pre><span></span>&gt; Topic Hello-kafka marked <span class="k">for</span> deletion
</pre></div>


<p>注意： 该操作只有在Broker的配置文件中设置了选项delete.topic.enable=true才可以。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://xmenfolk.github.io/tag/technologyarchitecture.html">[TechnologyArchitecture]</a>
    </p>
  </div>
  <div class="center social-share">
    <p>Like this article? Share it with your friends!</p>
    <div class="addthis_native_toolbox"></div>
    <div class="addthis_sharing_toolbox"></div>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'test-test';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
      <p>&copy; Angie 2017</p>
      <!--
        <p>&copy; Angie 2017</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>      -->
    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76772420-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-XX3242XX" async="async"></script>


<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "KafKa入门",
  "headline": "KafKa入门",
  "datePublished": "2017-04-19 00:00:00-03:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Angie",
    "url": "https://xmenfolk.github.io/author/angie.html"
  },
  "image": "/images/profile.jpg",
  "url": "https://xmenfolk.github.io/posts/kafkaIntroduction/",
  "description": "kafka背景 Kafka最初是由LinkedIn开发，并于2011年成为Apache的一个开源项目，随后在2012变为Apache的一个顶级项目。kafka是由Scala和Java语言编写的的。Kafka是一个基于发布-订阅，具有容错的消息系统。具有高性能，可扩展，分布式等特性。 kafka介绍 在大数据领域中，我们会使用了大量的数据。 关于大数据，我们有两个主要挑战。第一个挑战是如何收集大量的数据，第二个挑战是分析收集到的数据。为了克服这些挑战，你需要一个消息系统。Kafka的设计目标就是称为一个分布式，高吞吐量的消息系统。Kafka也可以作为一个传统的消息中间件的替代品。 与其他消息系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。 什么是消息系统？ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循pub-sub。 点对点消息系统 在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。 下图描述了结构。 发布-订阅消息系统 在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 一个现实生活的例子是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并在这些订阅的频道可用时获得它们。 kafka是什么？ Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。 优点 以下是Kafka的几个优点： 可靠性 - Kafka 是一个分布式，消息分区的，拥有消息复制和容错的系统。 扩展性 - Kafka消息系统可以实现在线扩展 可用性 - Kafka 使用 “分布式的commit log”，这也意味着消息会尽可能快的持久化到磁盘。 高性能 - Kafka 针对消息发送和消费都有很高的吞吐量。 即使保存了TB级别的数据性能也不会下降。 Kafka 非常快并保证零宕机和零消息丢失。 用例 kafka通常用于下面的使用场景： 监控 Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。 日志聚合方案 kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。 流式处理 流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行处理，然后将处理的结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。 need for Kafka Kafka是一个统一的平台，用于处理所有实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供对容错的保证。它具有处理大量不同消费者的能力。 Kafka非常快，执行2百万w/s。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统（RAM）的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。 Kafka基础概念 在深入了解Kafka之前，你应该先了解一些基本的术语。像topics,brokers,producers,consumers。下图说明了主要的术语并且表格对这些术语进行了详细的解释。 在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0, 1, 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。 假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上 …"
}
</script></body>
</html>